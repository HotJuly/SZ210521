# 组件懒加载

1. 前言
   1. Vue项目上线之前,以生产环境打包代码,最终文件夹中具有哪些文件?
      1. index.html
      2. index.js
      3. 普通情况下,打包之后只剩下这两个文件,也就是说index.js中具有绝大部分的代码
   2. 假设当前项目具有10个组件,每个组件体积1MB
      1. 也就是说,当前的index.js体积应该大于10MB
      2. 如果用户请求当前项目,会将整个index.js文件请求回去,此时体积10MB
      3. 用户有可能只进入首页,那么其他剩余的9个组件代码,就白请求了
      4. 最终出现问题:
         1. 由于首次请求的数据量增大,占用带宽较多,增加服务器压力
         2. 由于代码量较多,编译花费的时间增加,最终**导致页面渲染减慢,白屏时间增加**
   3. ES6模块化
      1. import...from...(静态引入)
         1. 编译时机:在项目打包时,就会将所有依赖的文件统一塞入main.js中
         2. 总结:项目上线之后,import...from...引入语句就不存在,所以读取所需代码都是从内存中读取
      2. import()(动态引入)
         1. 编译时机:在项目打包时,如果遇到import函数,webpack会将被引入的代码单独切割成为一个js文件,单独存放
         2. 总结:项目上线之后,如果使用到切割出去的代码,会重新请求服务器获取
   4. 组件懒加载
      1. 例如:当前项目具有10个组件,每个组件体积1MB,我们将多余的9个组件都是用组件懒加载进行切割
      2. 如果用户请求当前项目,会将整个index.js文件请求回去,但是此时体积1MB
      3. 如果后续需要用到其余9个组件代码,需要重新发送网络请求获取
2. 总结:
   1. 优点:
      1. 较小首次页面请求的数据量,提高页面编译速度,**加快页面首屏渲染速度,缩短白屏时间**
   2. 缺点:
      1. 由于进行代码切割之后,部分组件代码没有一次性拉取回来,最终部分组件代码还存于服务器上,导致需要展示其余页面时,需要发送网络请求,**导致后续页面渲染速度变慢**
3. 组件预加载
   1. 在用户当前浏览器空闲状态,趁用户不注意,偷偷的请求后续可能用到的组件
   2. 提前将可能需要用的资源请求回来,放在浏览器的内存中,方便用户后续的使用
   3. 优点:
      1. 可以提高后续页面渲染速度,解决组件懒加载的缺点
   4. 缺点:
      1. 比较浪费流量

